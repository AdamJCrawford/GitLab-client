/*
 * GitLab API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: v4
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package client

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type DeploymentsApiService service

/*
DeploymentsApiService Delete a specific deployment
Delete a specific deployment that is not currently the last deployment for an environment or in a running state. This feature was introduced in GitLab 15.3.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project owned by the authenticated user
  - @param deploymentId The ID of the deployment
*/
func (a *DeploymentsApiService) DeleteApiV4ProjectsIdDeploymentsDeploymentId(ctx context.Context, id string, deploymentId int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/deployments/{deployment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", fmt.Sprintf("%v", deploymentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DeploymentsApiService List project deployments
Get a list of deployments in a project. This feature was introduced in GitLab 8.11.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project owned by the authenticated user
 * @param optional nil or *DeploymentsApiGetApiV4ProjectsIdDeploymentsOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page
     * @param "OrderBy" (optional.String) -  Return deployments ordered by either one of &#x60;id&#x60;, &#x60;iid&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60; or &#x60;ref&#x60; fields. Default is &#x60;id&#x60;
     * @param "Sort" (optional.String) -  Return deployments sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order. Default is &#x60;asc&#x60;
     * @param "UpdatedAfter" (optional.Time) -  Return deployments updated after the specified date. Expected in ISO 8601 format (&#x60;2019-03-15T08:00:00Z&#x60;)
     * @param "UpdatedBefore" (optional.Time) -  Return deployments updated before the specified date. Expected in ISO 8601 format (&#x60;2019-03-15T08:00:00Z&#x60;)
     * @param "FinishedAfter" (optional.Time) -  Return deployments finished after the specified date. Expected in ISO 8601 format (&#x60;2019-03-15T08:00:00Z&#x60;)
     * @param "FinishedBefore" (optional.Time) -  Return deployments finished before the specified date. Expected in ISO 8601 format (&#x60;2019-03-15T08:00:00Z&#x60;)
     * @param "Environment" (optional.String) -  The name of the environment to filter deployments by
     * @param "Status" (optional.String) -  The status to filter deployments by. One of &#x60;created&#x60;, &#x60;running&#x60;, &#x60;success&#x60;, &#x60;failed&#x60;, &#x60;canceled&#x60;, or &#x60;blocked&#x60;

@return []ApiEntitiesDeployment
*/

type DeploymentsApiGetApiV4ProjectsIdDeploymentsOpts struct {
	Page           optional.Int32
	PerPage        optional.Int32
	OrderBy        optional.String
	Sort           optional.String
	UpdatedAfter   optional.Time
	UpdatedBefore  optional.Time
	FinishedAfter  optional.Time
	FinishedBefore optional.Time
	Environment    optional.String
	Status         optional.String
}

func (a *DeploymentsApiService) GetApiV4ProjectsIdDeployments(ctx context.Context, id string, localVarOptionals *DeploymentsApiGetApiV4ProjectsIdDeploymentsOpts) ([]ApiEntitiesDeployment, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []ApiEntitiesDeployment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedAfter.IsSet() {
		localVarQueryParams.Add("updated_after", parameterToString(localVarOptionals.UpdatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedBefore.IsSet() {
		localVarQueryParams.Add("updated_before", parameterToString(localVarOptionals.UpdatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FinishedAfter.IsSet() {
		localVarQueryParams.Add("finished_after", parameterToString(localVarOptionals.FinishedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FinishedBefore.IsSet() {
		localVarQueryParams.Add("finished_before", parameterToString(localVarOptionals.FinishedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Environment.IsSet() {
		localVarQueryParams.Add("environment", parameterToString(localVarOptionals.Environment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []ApiEntitiesDeployment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DeploymentsApiService Get a specific deployment
This feature was introduced in GitLab 8.11.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project owned by the authenticated user
  - @param deploymentId The ID of the deployment

@return ApiEntitiesDeploymentExtended
*/
func (a *DeploymentsApiService) GetApiV4ProjectsIdDeploymentsDeploymentId(ctx context.Context, id string, deploymentId int32) (ApiEntitiesDeploymentExtended, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesDeploymentExtended
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/deployments/{deployment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", fmt.Sprintf("%v", deploymentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesDeploymentExtended
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DeploymentsApiService List of merge requests associated with a deployment
Retrieves the list of merge requests shipped with a given deployment. This feature was introduced in GitLab 12.7.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project owned by the authenticated user
 * @param deploymentId The ID of the deployment
 * @param optional nil or *DeploymentsApiGetApiV4ProjectsIdDeploymentsDeploymentIdMergeRequestsOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page
     * @param "AuthorId" (optional.Int32) -  Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "AuthorUsername" (optional.String) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "AssigneeId" (optional.Int32) -  Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "AssigneeUsername" (optional.Interface of []string) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "ReviewerUsername" (optional.String) -  Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "Labels" (optional.Interface of []string) -  Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "Milestone" (optional.String) -  Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "MyReactionEmoji" (optional.String) -  Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "ReviewerId" (optional.Int32) -  Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "State" (optional.String) -  Returns &#x60;all&#x60; merge requests or just those that are &#x60;opened&#x60;, &#x60;closed&#x60;, &#x60;locked&#x60;, or &#x60;merged&#x60;.
     * @param "OrderBy" (optional.String) -  Returns merge requests ordered by &#x60;created_at&#x60;, &#x60;label_priority&#x60;, &#x60;milestone_due&#x60;, &#x60;popularity&#x60;, &#x60;priority&#x60;, &#x60;title&#x60; or &#x60;updated_at&#x60; fields. Introduced in GitLab 14.8.
     * @param "Sort" (optional.String) -  Returns merge requests sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order.
     * @param "WithLabelsDetails" (optional.Bool) -  If &#x60;true&#x60;, response returns more details for each label in labels field: &#x60;:name&#x60;,&#x60;:color&#x60;, &#x60;:description&#x60;, &#x60;:description_html&#x60;, &#x60;:text_color&#x60;
     * @param "WithMergeStatusRecheck" (optional.Bool) -  If &#x60;true&#x60;, this projection requests (but does not guarantee) that the &#x60;merge_status&#x60; field be recalculated asynchronously. Introduced in GitLab 13.0.
     * @param "CreatedAfter" (optional.Time) -  Returns merge requests created on or after the given time. Expected in ISO 8601 format.
     * @param "CreatedBefore" (optional.Time) -  Returns merge requests created on or before the given time. Expected in ISO 8601 format.
     * @param "UpdatedAfter" (optional.Time) -  Returns merge requests updated on or after the given time. Expected in ISO 8601 format.
     * @param "UpdatedBefore" (optional.Time) -  Returns merge requests updated on or before the given time. Expected in ISO 8601 format.
     * @param "View" (optional.String) -  If simple, returns the &#x60;iid&#x60;, URL, title, description, and basic state of merge request
     * @param "Scope" (optional.String) -  Returns merge requests for the given scope: &#x60;created_by_me&#x60;, &#x60;assigned_to_me&#x60; or &#x60;all&#x60;
     * @param "SourceBranch" (optional.String) -  Returns merge requests with the given source branch
     * @param "SourceProjectId" (optional.Int32) -  Returns merge requests with the given source project id
     * @param "TargetBranch" (optional.String) -  Returns merge requests with the given target branch
     * @param "Search" (optional.String) -  Search merge requests against their &#x60;title&#x60; and &#x60;description&#x60;.
     * @param "In" (optional.String) -  Modify the scope of the search attribute. &#x60;title&#x60;, &#x60;description&#x60;, or a string joining them with comma.
     * @param "Wip" (optional.String) -  Filter merge requests against their &#x60;wip&#x60; status. &#x60;yes&#x60; to return only draft merge requests, &#x60;no&#x60; to return non-draft merge requests.
     * @param "NotAuthorId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "NotAuthorUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotAssigneeId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "NotAssigneeUsername" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotReviewerUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "NotLabels" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "NotMilestone" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "NotMyReactionEmoji" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "NotReviewerId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "DeployedBefore" (optional.String) -  Returns merge requests deployed before the given date/time. Expected in ISO 8601 format.
     * @param "DeployedAfter" (optional.String) -  Returns merge requests deployed after the given date/time. Expected in ISO 8601 format
     * @param "Environment" (optional.String) -  Returns merge requests deployed to the given environment
     * @param "Approved" (optional.String) -  Filters merge requests by their &#x60;approved&#x60; status. &#x60;yes&#x60; returns only approved merge requests. &#x60;no&#x60; returns only non-approved merge requests.
     * @param "MergeUserId" (optional.Int32) -  Returns merge requests which have been merged by the user with the given user &#x60;id&#x60;. Mutually exclusive with &#x60;merge_user_username&#x60;.
     * @param "MergeUserUsername" (optional.String) -  Returns merge requests which have been merged by the user with the given &#x60;username&#x60;. Mutually exclusive with &#x60;merge_user_id&#x60;.

@return []ApiEntitiesMergeRequestBasic
*/

type DeploymentsApiGetApiV4ProjectsIdDeploymentsDeploymentIdMergeRequestsOpts struct {
	Page                   optional.Int32
	PerPage                optional.Int32
	AuthorId               optional.Int32
	AuthorUsername         optional.String
	AssigneeId             optional.Int32
	AssigneeUsername       optional.Interface
	ReviewerUsername       optional.String
	Labels                 optional.Interface
	Milestone              optional.String
	MyReactionEmoji        optional.String
	ReviewerId             optional.Int32
	State                  optional.String
	OrderBy                optional.String
	Sort                   optional.String
	WithLabelsDetails      optional.Bool
	WithMergeStatusRecheck optional.Bool
	CreatedAfter           optional.Time
	CreatedBefore          optional.Time
	UpdatedAfter           optional.Time
	UpdatedBefore          optional.Time
	View                   optional.String
	Scope                  optional.String
	SourceBranch           optional.String
	SourceProjectId        optional.Int32
	TargetBranch           optional.String
	Search                 optional.String
	In                     optional.String
	Wip                    optional.String
	NotAuthorId            optional.Int32
	NotAuthorUsername      optional.String
	NotAssigneeId          optional.Int32
	NotAssigneeUsername    optional.Interface
	NotReviewerUsername    optional.String
	NotLabels              optional.Interface
	NotMilestone           optional.String
	NotMyReactionEmoji     optional.String
	NotReviewerId          optional.Int32
	DeployedBefore         optional.String
	DeployedAfter          optional.String
	Environment            optional.String
	Approved               optional.String
	MergeUserId            optional.Int32
	MergeUserUsername      optional.String
}

func (a *DeploymentsApiService) GetApiV4ProjectsIdDeploymentsDeploymentIdMergeRequests(ctx context.Context, id string, deploymentId int32, localVarOptionals *DeploymentsApiGetApiV4ProjectsIdDeploymentsDeploymentIdMergeRequestsOpts) ([]ApiEntitiesMergeRequestBasic, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []ApiEntitiesMergeRequestBasic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/deployments/{deployment_id}/merge_requests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", fmt.Sprintf("%v", deploymentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthorId.IsSet() {
		localVarQueryParams.Add("author_id", parameterToString(localVarOptionals.AuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthorUsername.IsSet() {
		localVarQueryParams.Add("author_username", parameterToString(localVarOptionals.AuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeId.IsSet() {
		localVarQueryParams.Add("assignee_id", parameterToString(localVarOptionals.AssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeUsername.IsSet() {
		localVarQueryParams.Add("assignee_username", parameterToString(localVarOptionals.AssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerUsername.IsSet() {
		localVarQueryParams.Add("reviewer_username", parameterToString(localVarOptionals.ReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Labels.IsSet() {
		localVarQueryParams.Add("labels", parameterToString(localVarOptionals.Labels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Milestone.IsSet() {
		localVarQueryParams.Add("milestone", parameterToString(localVarOptionals.Milestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MyReactionEmoji.IsSet() {
		localVarQueryParams.Add("my_reaction_emoji", parameterToString(localVarOptionals.MyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerId.IsSet() {
		localVarQueryParams.Add("reviewer_id", parameterToString(localVarOptionals.ReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithLabelsDetails.IsSet() {
		localVarQueryParams.Add("with_labels_details", parameterToString(localVarOptionals.WithLabelsDetails.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithMergeStatusRecheck.IsSet() {
		localVarQueryParams.Add("with_merge_status_recheck", parameterToString(localVarOptionals.WithMergeStatusRecheck.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedAfter.IsSet() {
		localVarQueryParams.Add("created_after", parameterToString(localVarOptionals.CreatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedBefore.IsSet() {
		localVarQueryParams.Add("created_before", parameterToString(localVarOptionals.CreatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedAfter.IsSet() {
		localVarQueryParams.Add("updated_after", parameterToString(localVarOptionals.UpdatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedBefore.IsSet() {
		localVarQueryParams.Add("updated_before", parameterToString(localVarOptionals.UpdatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceBranch.IsSet() {
		localVarQueryParams.Add("source_branch", parameterToString(localVarOptionals.SourceBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceProjectId.IsSet() {
		localVarQueryParams.Add("source_project_id", parameterToString(localVarOptionals.SourceProjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetBranch.IsSet() {
		localVarQueryParams.Add("target_branch", parameterToString(localVarOptionals.TargetBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.In.IsSet() {
		localVarQueryParams.Add("in", parameterToString(localVarOptionals.In.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wip.IsSet() {
		localVarQueryParams.Add("wip", parameterToString(localVarOptionals.Wip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorId.IsSet() {
		localVarQueryParams.Add("not[author_id]", parameterToString(localVarOptionals.NotAuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorUsername.IsSet() {
		localVarQueryParams.Add("not[author_username]", parameterToString(localVarOptionals.NotAuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeId.IsSet() {
		localVarQueryParams.Add("not[assignee_id]", parameterToString(localVarOptionals.NotAssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeUsername.IsSet() {
		localVarQueryParams.Add("not[assignee_username]", parameterToString(localVarOptionals.NotAssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerUsername.IsSet() {
		localVarQueryParams.Add("not[reviewer_username]", parameterToString(localVarOptionals.NotReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotLabels.IsSet() {
		localVarQueryParams.Add("not[labels]", parameterToString(localVarOptionals.NotLabels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotMilestone.IsSet() {
		localVarQueryParams.Add("not[milestone]", parameterToString(localVarOptionals.NotMilestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotMyReactionEmoji.IsSet() {
		localVarQueryParams.Add("not[my_reaction_emoji]", parameterToString(localVarOptionals.NotMyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerId.IsSet() {
		localVarQueryParams.Add("not[reviewer_id]", parameterToString(localVarOptionals.NotReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedBefore.IsSet() {
		localVarQueryParams.Add("deployed_before", parameterToString(localVarOptionals.DeployedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedAfter.IsSet() {
		localVarQueryParams.Add("deployed_after", parameterToString(localVarOptionals.DeployedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Environment.IsSet() {
		localVarQueryParams.Add("environment", parameterToString(localVarOptionals.Environment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Approved.IsSet() {
		localVarQueryParams.Add("approved", parameterToString(localVarOptionals.Approved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserId.IsSet() {
		localVarQueryParams.Add("merge_user_id", parameterToString(localVarOptionals.MergeUserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserUsername.IsSet() {
		localVarQueryParams.Add("merge_user_username", parameterToString(localVarOptionals.MergeUserUsername.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []ApiEntitiesMergeRequestBasic
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DeploymentsApiService Create a deployment
This feature was introduced in GitLab 12.4.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project owned by the authenticated user
  - @param postApiV4ProjectsIdDeployments

@return ApiEntitiesDeploymentExtended
*/
func (a *DeploymentsApiService) PostApiV4ProjectsIdDeployments(ctx context.Context, id string, postApiV4ProjectsIdDeployments PostApiV4ProjectsIdDeployments) (ApiEntitiesDeploymentExtended, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesDeploymentExtended
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &postApiV4ProjectsIdDeployments
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesDeploymentExtended
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DeploymentsApiService Approve or reject a blocked deployment
This feature was introduced in GitLab 14.8.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project owned by the authenticated user
  - @param deploymentId The ID of the deployment
  - @param postApiV4ProjectsIdDeploymentsDeploymentIdApproval

@return ApiEntitiesDeploymentsApproval
*/
func (a *DeploymentsApiService) PostApiV4ProjectsIdDeploymentsDeploymentIdApproval(ctx context.Context, id string, deploymentId int32, postApiV4ProjectsIdDeploymentsDeploymentIdApproval PostApiV4ProjectsIdDeploymentsDeploymentIdApproval) (ApiEntitiesDeploymentsApproval, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesDeploymentsApproval
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/deployments/{deployment_id}/approval"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", fmt.Sprintf("%v", deploymentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &postApiV4ProjectsIdDeploymentsDeploymentIdApproval
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesDeploymentsApproval
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DeploymentsApiService Update a deployment
This feature was introduced in GitLab 12.4.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project owned by the authenticated user
  - @param deploymentId
  - @param putApiV4ProjectsIdDeploymentsDeploymentId

@return ApiEntitiesDeploymentExtended
*/
func (a *DeploymentsApiService) PutApiV4ProjectsIdDeploymentsDeploymentId(ctx context.Context, id string, deploymentId int32, putApiV4ProjectsIdDeploymentsDeploymentId PutApiV4ProjectsIdDeploymentsDeploymentId) (ApiEntitiesDeploymentExtended, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesDeploymentExtended
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/deployments/{deployment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", fmt.Sprintf("%v", deploymentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &putApiV4ProjectsIdDeploymentsDeploymentId
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesDeploymentExtended
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
