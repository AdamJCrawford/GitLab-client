/*
 * GitLab API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: v4
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type MergeRequestsApiService service

/*
MergeRequestsApiService Delete a merge request
Only for administrators and project owners. Deletes the merge request in question.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid The internal ID of the merge request.
*/
func (a *MergeRequestsApiService) DeleteApiV4ProjectsIdMergeRequestsMergeRequestIid(ctx context.Context, id string, mergeRequestIid int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
MergeRequestsApiService Delete merge request context commits
Delete a list of merge request context commits.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param commits The context commitsâ€™ SHA.
  - @param mergeRequestIid
*/
func (a *MergeRequestsApiService) DeleteApiV4ProjectsIdMergeRequestsMergeRequestIidContextCommits(ctx context.Context, id string, commits []string, mergeRequestIid int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/context_commits"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("commits", parameterToString(commits, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
MergeRequestsApiService List group merge requests
Get all merge requests for this group and its subgroups.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the group owned by the authenticated user.
 * @param optional nil or *MergeRequestsApiGetApiV4GroupsIdMergeRequestsOpts - Optional Parameters:
     * @param "AuthorId" (optional.Int32) -  Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "AuthorUsername" (optional.String) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "AssigneeId" (optional.Int32) -  Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "AssigneeUsername" (optional.Interface of []string) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "ReviewerUsername" (optional.String) -  Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "Labels" (optional.Interface of []string) -  Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "Milestone" (optional.String) -  Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "MyReactionEmoji" (optional.String) -  Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "ReviewerId" (optional.Int32) -  Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "State" (optional.String) -  Returns &#x60;all&#x60; merge requests or just those that are &#x60;opened&#x60;, &#x60;closed&#x60;, &#x60;locked&#x60;, or &#x60;merged&#x60;.
     * @param "OrderBy" (optional.String) -  Returns merge requests ordered by &#x60;created_at&#x60;, &#x60;label_priority&#x60;, &#x60;milestone_due&#x60;, &#x60;popularity&#x60;, &#x60;priority&#x60;, &#x60;title&#x60; or &#x60;updated_at&#x60; fields. Introduced in GitLab 14.8.
     * @param "Sort" (optional.String) -  Returns merge requests sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order.
     * @param "WithLabelsDetails" (optional.Bool) -  If &#x60;true&#x60;, response returns more details for each label in labels field: &#x60;:name&#x60;,&#x60;:color&#x60;, &#x60;:description&#x60;, &#x60;:description_html&#x60;, &#x60;:text_color&#x60;
     * @param "WithMergeStatusRecheck" (optional.Bool) -  If &#x60;true&#x60;, this projection requests (but does not guarantee) that the &#x60;merge_status&#x60; field be recalculated asynchronously. Introduced in GitLab 13.0.
     * @param "CreatedAfter" (optional.Time) -  Returns merge requests created on or after the given time. Expected in ISO 8601 format.
     * @param "CreatedBefore" (optional.Time) -  Returns merge requests created on or before the given time. Expected in ISO 8601 format.
     * @param "UpdatedAfter" (optional.Time) -  Returns merge requests updated on or after the given time. Expected in ISO 8601 format.
     * @param "UpdatedBefore" (optional.Time) -  Returns merge requests updated on or before the given time. Expected in ISO 8601 format.
     * @param "View" (optional.String) -  If simple, returns the &#x60;iid&#x60;, URL, title, description, and basic state of merge request
     * @param "Scope" (optional.String) -  Returns merge requests for the given scope: &#x60;created_by_me&#x60;, &#x60;assigned_to_me&#x60; or &#x60;all&#x60;
     * @param "SourceBranch" (optional.String) -  Returns merge requests with the given source branch
     * @param "SourceProjectId" (optional.Int32) -  Returns merge requests with the given source project id
     * @param "TargetBranch" (optional.String) -  Returns merge requests with the given target branch
     * @param "Search" (optional.String) -  Search merge requests against their &#x60;title&#x60; and &#x60;description&#x60;.
     * @param "In" (optional.String) -  Modify the scope of the search attribute. &#x60;title&#x60;, &#x60;description&#x60;, or a string joining them with comma.
     * @param "Wip" (optional.String) -  Filter merge requests against their &#x60;wip&#x60; status. &#x60;yes&#x60; to return only draft merge requests, &#x60;no&#x60; to return non-draft merge requests.
     * @param "NotAuthorId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "NotAuthorUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotAssigneeId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "NotAssigneeUsername" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotReviewerUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "NotLabels" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "NotMilestone" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "NotMyReactionEmoji" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "NotReviewerId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "DeployedBefore" (optional.String) -  Returns merge requests deployed before the given date/time. Expected in ISO 8601 format.
     * @param "DeployedAfter" (optional.String) -  Returns merge requests deployed after the given date/time. Expected in ISO 8601 format
     * @param "Environment" (optional.String) -  Returns merge requests deployed to the given environment
     * @param "Approved" (optional.String) -  Filters merge requests by their &#x60;approved&#x60; status. &#x60;yes&#x60; returns only approved merge requests. &#x60;no&#x60; returns only non-approved merge requests.
     * @param "MergeUserId" (optional.Int32) -  Returns merge requests which have been merged by the user with the given user &#x60;id&#x60;. Mutually exclusive with &#x60;merge_user_username&#x60;.
     * @param "MergeUserUsername" (optional.String) -  Returns merge requests which have been merged by the user with the given &#x60;username&#x60;. Mutually exclusive with &#x60;merge_user_id&#x60;.
     * @param "ApproverIds" (optional.String) -  Return merge requests which have specified the users with the given IDs as an individual approver
     * @param "ApprovedByIds" (optional.String) -  Return merge requests which have been approved by the specified users with the given IDs
     * @param "ApprovedByUsernames" (optional.String) -  Return merge requests which have been approved by the specified users with the given             usernames
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page
     * @param "NonArchived" (optional.Bool) -  Returns merge requests from non archived projects only.

@return ApiEntitiesMergeRequestBasic
*/

type MergeRequestsApiGetApiV4GroupsIdMergeRequestsOpts struct {
	AuthorId               optional.Int32
	AuthorUsername         optional.String
	AssigneeId             optional.Int32
	AssigneeUsername       optional.Interface
	ReviewerUsername       optional.String
	Labels                 optional.Interface
	Milestone              optional.String
	MyReactionEmoji        optional.String
	ReviewerId             optional.Int32
	State                  optional.String
	OrderBy                optional.String
	Sort                   optional.String
	WithLabelsDetails      optional.Bool
	WithMergeStatusRecheck optional.Bool
	CreatedAfter           optional.Time
	CreatedBefore          optional.Time
	UpdatedAfter           optional.Time
	UpdatedBefore          optional.Time
	View                   optional.String
	Scope                  optional.String
	SourceBranch           optional.String
	SourceProjectId        optional.Int32
	TargetBranch           optional.String
	Search                 optional.String
	In                     optional.String
	Wip                    optional.String
	NotAuthorId            optional.Int32
	NotAuthorUsername      optional.String
	NotAssigneeId          optional.Int32
	NotAssigneeUsername    optional.Interface
	NotReviewerUsername    optional.String
	NotLabels              optional.Interface
	NotMilestone           optional.String
	NotMyReactionEmoji     optional.String
	NotReviewerId          optional.Int32
	DeployedBefore         optional.String
	DeployedAfter          optional.String
	Environment            optional.String
	Approved               optional.String
	MergeUserId            optional.Int32
	MergeUserUsername      optional.String
	ApproverIds            optional.String
	ApprovedByIds          optional.String
	ApprovedByUsernames    optional.String
	Page                   optional.Int32
	PerPage                optional.Int32
	NonArchived            optional.Bool
}

func (a *MergeRequestsApiService) GetApiV4GroupsIdMergeRequests(ctx context.Context, id string, localVarOptionals *MergeRequestsApiGetApiV4GroupsIdMergeRequestsOpts) (ApiEntitiesMergeRequestBasic, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequestBasic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/groups/{id}/merge_requests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AuthorId.IsSet() {
		localVarQueryParams.Add("author_id", parameterToString(localVarOptionals.AuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthorUsername.IsSet() {
		localVarQueryParams.Add("author_username", parameterToString(localVarOptionals.AuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeId.IsSet() {
		localVarQueryParams.Add("assignee_id", parameterToString(localVarOptionals.AssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeUsername.IsSet() {
		localVarQueryParams.Add("assignee_username", parameterToString(localVarOptionals.AssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerUsername.IsSet() {
		localVarQueryParams.Add("reviewer_username", parameterToString(localVarOptionals.ReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Labels.IsSet() {
		localVarQueryParams.Add("labels", parameterToString(localVarOptionals.Labels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Milestone.IsSet() {
		localVarQueryParams.Add("milestone", parameterToString(localVarOptionals.Milestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MyReactionEmoji.IsSet() {
		localVarQueryParams.Add("my_reaction_emoji", parameterToString(localVarOptionals.MyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerId.IsSet() {
		localVarQueryParams.Add("reviewer_id", parameterToString(localVarOptionals.ReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithLabelsDetails.IsSet() {
		localVarQueryParams.Add("with_labels_details", parameterToString(localVarOptionals.WithLabelsDetails.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithMergeStatusRecheck.IsSet() {
		localVarQueryParams.Add("with_merge_status_recheck", parameterToString(localVarOptionals.WithMergeStatusRecheck.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedAfter.IsSet() {
		localVarQueryParams.Add("created_after", parameterToString(localVarOptionals.CreatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedBefore.IsSet() {
		localVarQueryParams.Add("created_before", parameterToString(localVarOptionals.CreatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedAfter.IsSet() {
		localVarQueryParams.Add("updated_after", parameterToString(localVarOptionals.UpdatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedBefore.IsSet() {
		localVarQueryParams.Add("updated_before", parameterToString(localVarOptionals.UpdatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceBranch.IsSet() {
		localVarQueryParams.Add("source_branch", parameterToString(localVarOptionals.SourceBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceProjectId.IsSet() {
		localVarQueryParams.Add("source_project_id", parameterToString(localVarOptionals.SourceProjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetBranch.IsSet() {
		localVarQueryParams.Add("target_branch", parameterToString(localVarOptionals.TargetBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.In.IsSet() {
		localVarQueryParams.Add("in", parameterToString(localVarOptionals.In.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wip.IsSet() {
		localVarQueryParams.Add("wip", parameterToString(localVarOptionals.Wip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorId.IsSet() {
		localVarQueryParams.Add("not[author_id]", parameterToString(localVarOptionals.NotAuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorUsername.IsSet() {
		localVarQueryParams.Add("not[author_username]", parameterToString(localVarOptionals.NotAuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeId.IsSet() {
		localVarQueryParams.Add("not[assignee_id]", parameterToString(localVarOptionals.NotAssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeUsername.IsSet() {
		localVarQueryParams.Add("not[assignee_username]", parameterToString(localVarOptionals.NotAssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerUsername.IsSet() {
		localVarQueryParams.Add("not[reviewer_username]", parameterToString(localVarOptionals.NotReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotLabels.IsSet() {
		localVarQueryParams.Add("not[labels]", parameterToString(localVarOptionals.NotLabels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotMilestone.IsSet() {
		localVarQueryParams.Add("not[milestone]", parameterToString(localVarOptionals.NotMilestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotMyReactionEmoji.IsSet() {
		localVarQueryParams.Add("not[my_reaction_emoji]", parameterToString(localVarOptionals.NotMyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerId.IsSet() {
		localVarQueryParams.Add("not[reviewer_id]", parameterToString(localVarOptionals.NotReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedBefore.IsSet() {
		localVarQueryParams.Add("deployed_before", parameterToString(localVarOptionals.DeployedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedAfter.IsSet() {
		localVarQueryParams.Add("deployed_after", parameterToString(localVarOptionals.DeployedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Environment.IsSet() {
		localVarQueryParams.Add("environment", parameterToString(localVarOptionals.Environment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Approved.IsSet() {
		localVarQueryParams.Add("approved", parameterToString(localVarOptionals.Approved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserId.IsSet() {
		localVarQueryParams.Add("merge_user_id", parameterToString(localVarOptionals.MergeUserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserUsername.IsSet() {
		localVarQueryParams.Add("merge_user_username", parameterToString(localVarOptionals.MergeUserUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApproverIds.IsSet() {
		localVarQueryParams.Add("approver_ids", parameterToString(localVarOptionals.ApproverIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApprovedByIds.IsSet() {
		localVarQueryParams.Add("approved_by_ids", parameterToString(localVarOptionals.ApprovedByIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApprovedByUsernames.IsSet() {
		localVarQueryParams.Add("approved_by_usernames", parameterToString(localVarOptionals.ApprovedByUsernames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NonArchived.IsSet() {
		localVarQueryParams.Add("non_archived", parameterToString(localVarOptionals.NonArchived.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequestBasic
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService List merge requests
Get all merge requests the authenticated user has access to. By default it returns only merge requests created by the current user. To get all merge requests, use parameter &#x60;scope&#x3D;all&#x60;.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *MergeRequestsApiGetApiV4MergeRequestsOpts - Optional Parameters:
     * @param "AuthorId" (optional.Int32) -  Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "AuthorUsername" (optional.String) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "AssigneeId" (optional.Int32) -  Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "AssigneeUsername" (optional.Interface of []string) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "ReviewerUsername" (optional.String) -  Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "Labels" (optional.Interface of []string) -  Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "Milestone" (optional.String) -  Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "MyReactionEmoji" (optional.String) -  Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "ReviewerId" (optional.Int32) -  Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "State" (optional.String) -  Returns &#x60;all&#x60; merge requests or just those that are &#x60;opened&#x60;, &#x60;closed&#x60;, &#x60;locked&#x60;, or &#x60;merged&#x60;.
     * @param "OrderBy" (optional.String) -  Returns merge requests ordered by &#x60;created_at&#x60;, &#x60;label_priority&#x60;, &#x60;milestone_due&#x60;, &#x60;popularity&#x60;, &#x60;priority&#x60;, &#x60;title&#x60; or &#x60;updated_at&#x60; fields. Introduced in GitLab 14.8.
     * @param "Sort" (optional.String) -  Returns merge requests sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order.
     * @param "WithLabelsDetails" (optional.Bool) -  If &#x60;true&#x60;, response returns more details for each label in labels field: &#x60;:name&#x60;,&#x60;:color&#x60;, &#x60;:description&#x60;, &#x60;:description_html&#x60;, &#x60;:text_color&#x60;
     * @param "WithMergeStatusRecheck" (optional.Bool) -  If &#x60;true&#x60;, this projection requests (but does not guarantee) that the &#x60;merge_status&#x60; field be recalculated asynchronously. Introduced in GitLab 13.0.
     * @param "CreatedAfter" (optional.Time) -  Returns merge requests created on or after the given time. Expected in ISO 8601 format.
     * @param "CreatedBefore" (optional.Time) -  Returns merge requests created on or before the given time. Expected in ISO 8601 format.
     * @param "UpdatedAfter" (optional.Time) -  Returns merge requests updated on or after the given time. Expected in ISO 8601 format.
     * @param "UpdatedBefore" (optional.Time) -  Returns merge requests updated on or before the given time. Expected in ISO 8601 format.
     * @param "View" (optional.String) -  If simple, returns the &#x60;iid&#x60;, URL, title, description, and basic state of merge request
     * @param "Scope" (optional.String) -  Returns merge requests for the given scope: &#x60;created_by_me&#x60;, &#x60;assigned_to_me&#x60; or &#x60;all&#x60;
     * @param "SourceBranch" (optional.String) -  Returns merge requests with the given source branch
     * @param "SourceProjectId" (optional.Int32) -  Returns merge requests with the given source project id
     * @param "TargetBranch" (optional.String) -  Returns merge requests with the given target branch
     * @param "Search" (optional.String) -  Search merge requests against their &#x60;title&#x60; and &#x60;description&#x60;.
     * @param "In" (optional.String) -  Modify the scope of the search attribute. &#x60;title&#x60;, &#x60;description&#x60;, or a string joining them with comma.
     * @param "Wip" (optional.String) -  Filter merge requests against their &#x60;wip&#x60; status. &#x60;yes&#x60; to return only draft merge requests, &#x60;no&#x60; to return non-draft merge requests.
     * @param "NotAuthorId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "NotAuthorUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotAssigneeId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "NotAssigneeUsername" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotReviewerUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "NotLabels" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "NotMilestone" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "NotMyReactionEmoji" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "NotReviewerId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "DeployedBefore" (optional.String) -  Returns merge requests deployed before the given date/time. Expected in ISO 8601 format.
     * @param "DeployedAfter" (optional.String) -  Returns merge requests deployed after the given date/time. Expected in ISO 8601 format
     * @param "Environment" (optional.String) -  Returns merge requests deployed to the given environment
     * @param "Approved" (optional.String) -  Filters merge requests by their &#x60;approved&#x60; status. &#x60;yes&#x60; returns only approved merge requests. &#x60;no&#x60; returns only non-approved merge requests.
     * @param "MergeUserId" (optional.Int32) -  Returns merge requests which have been merged by the user with the given user &#x60;id&#x60;. Mutually exclusive with &#x60;merge_user_username&#x60;.
     * @param "MergeUserUsername" (optional.String) -  Returns merge requests which have been merged by the user with the given &#x60;username&#x60;. Mutually exclusive with &#x60;merge_user_id&#x60;.
     * @param "ApproverIds" (optional.String) -  Return merge requests which have specified the users with the given IDs as an individual approver
     * @param "ApprovedByIds" (optional.String) -  Return merge requests which have been approved by the specified users with the given IDs
     * @param "ApprovedByUsernames" (optional.String) -  Return merge requests which have been approved by the specified users with the given             usernames
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page

@return ApiEntitiesMergeRequestBasic
*/

type MergeRequestsApiGetApiV4MergeRequestsOpts struct {
	AuthorId               optional.Int32
	AuthorUsername         optional.String
	AssigneeId             optional.Int32
	AssigneeUsername       optional.Interface
	ReviewerUsername       optional.String
	Labels                 optional.Interface
	Milestone              optional.String
	MyReactionEmoji        optional.String
	ReviewerId             optional.Int32
	State                  optional.String
	OrderBy                optional.String
	Sort                   optional.String
	WithLabelsDetails      optional.Bool
	WithMergeStatusRecheck optional.Bool
	CreatedAfter           optional.Time
	CreatedBefore          optional.Time
	UpdatedAfter           optional.Time
	UpdatedBefore          optional.Time
	View                   optional.String
	Scope                  optional.String
	SourceBranch           optional.String
	SourceProjectId        optional.Int32
	TargetBranch           optional.String
	Search                 optional.String
	In                     optional.String
	Wip                    optional.String
	NotAuthorId            optional.Int32
	NotAuthorUsername      optional.String
	NotAssigneeId          optional.Int32
	NotAssigneeUsername    optional.Interface
	NotReviewerUsername    optional.String
	NotLabels              optional.Interface
	NotMilestone           optional.String
	NotMyReactionEmoji     optional.String
	NotReviewerId          optional.Int32
	DeployedBefore         optional.String
	DeployedAfter          optional.String
	Environment            optional.String
	Approved               optional.String
	MergeUserId            optional.Int32
	MergeUserUsername      optional.String
	ApproverIds            optional.String
	ApprovedByIds          optional.String
	ApprovedByUsernames    optional.String
	Page                   optional.Int32
	PerPage                optional.Int32
}

func (a *MergeRequestsApiService) GetApiV4MergeRequests(ctx context.Context, localVarOptionals *MergeRequestsApiGetApiV4MergeRequestsOpts) (ApiEntitiesMergeRequestBasic, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequestBasic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/merge_requests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AuthorId.IsSet() {
		localVarQueryParams.Add("author_id", parameterToString(localVarOptionals.AuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthorUsername.IsSet() {
		localVarQueryParams.Add("author_username", parameterToString(localVarOptionals.AuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeId.IsSet() {
		localVarQueryParams.Add("assignee_id", parameterToString(localVarOptionals.AssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeUsername.IsSet() {
		localVarQueryParams.Add("assignee_username", parameterToString(localVarOptionals.AssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerUsername.IsSet() {
		localVarQueryParams.Add("reviewer_username", parameterToString(localVarOptionals.ReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Labels.IsSet() {
		localVarQueryParams.Add("labels", parameterToString(localVarOptionals.Labels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Milestone.IsSet() {
		localVarQueryParams.Add("milestone", parameterToString(localVarOptionals.Milestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MyReactionEmoji.IsSet() {
		localVarQueryParams.Add("my_reaction_emoji", parameterToString(localVarOptionals.MyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerId.IsSet() {
		localVarQueryParams.Add("reviewer_id", parameterToString(localVarOptionals.ReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithLabelsDetails.IsSet() {
		localVarQueryParams.Add("with_labels_details", parameterToString(localVarOptionals.WithLabelsDetails.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithMergeStatusRecheck.IsSet() {
		localVarQueryParams.Add("with_merge_status_recheck", parameterToString(localVarOptionals.WithMergeStatusRecheck.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedAfter.IsSet() {
		localVarQueryParams.Add("created_after", parameterToString(localVarOptionals.CreatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedBefore.IsSet() {
		localVarQueryParams.Add("created_before", parameterToString(localVarOptionals.CreatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedAfter.IsSet() {
		localVarQueryParams.Add("updated_after", parameterToString(localVarOptionals.UpdatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedBefore.IsSet() {
		localVarQueryParams.Add("updated_before", parameterToString(localVarOptionals.UpdatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceBranch.IsSet() {
		localVarQueryParams.Add("source_branch", parameterToString(localVarOptionals.SourceBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceProjectId.IsSet() {
		localVarQueryParams.Add("source_project_id", parameterToString(localVarOptionals.SourceProjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetBranch.IsSet() {
		localVarQueryParams.Add("target_branch", parameterToString(localVarOptionals.TargetBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.In.IsSet() {
		localVarQueryParams.Add("in", parameterToString(localVarOptionals.In.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wip.IsSet() {
		localVarQueryParams.Add("wip", parameterToString(localVarOptionals.Wip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorId.IsSet() {
		localVarQueryParams.Add("not[author_id]", parameterToString(localVarOptionals.NotAuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorUsername.IsSet() {
		localVarQueryParams.Add("not[author_username]", parameterToString(localVarOptionals.NotAuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeId.IsSet() {
		localVarQueryParams.Add("not[assignee_id]", parameterToString(localVarOptionals.NotAssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeUsername.IsSet() {
		localVarQueryParams.Add("not[assignee_username]", parameterToString(localVarOptionals.NotAssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerUsername.IsSet() {
		localVarQueryParams.Add("not[reviewer_username]", parameterToString(localVarOptionals.NotReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotLabels.IsSet() {
		localVarQueryParams.Add("not[labels]", parameterToString(localVarOptionals.NotLabels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotMilestone.IsSet() {
		localVarQueryParams.Add("not[milestone]", parameterToString(localVarOptionals.NotMilestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotMyReactionEmoji.IsSet() {
		localVarQueryParams.Add("not[my_reaction_emoji]", parameterToString(localVarOptionals.NotMyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerId.IsSet() {
		localVarQueryParams.Add("not[reviewer_id]", parameterToString(localVarOptionals.NotReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedBefore.IsSet() {
		localVarQueryParams.Add("deployed_before", parameterToString(localVarOptionals.DeployedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedAfter.IsSet() {
		localVarQueryParams.Add("deployed_after", parameterToString(localVarOptionals.DeployedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Environment.IsSet() {
		localVarQueryParams.Add("environment", parameterToString(localVarOptionals.Environment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Approved.IsSet() {
		localVarQueryParams.Add("approved", parameterToString(localVarOptionals.Approved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserId.IsSet() {
		localVarQueryParams.Add("merge_user_id", parameterToString(localVarOptionals.MergeUserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserUsername.IsSet() {
		localVarQueryParams.Add("merge_user_username", parameterToString(localVarOptionals.MergeUserUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApproverIds.IsSet() {
		localVarQueryParams.Add("approver_ids", parameterToString(localVarOptionals.ApproverIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApprovedByIds.IsSet() {
		localVarQueryParams.Add("approved_by_ids", parameterToString(localVarOptionals.ApprovedByIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApprovedByUsernames.IsSet() {
		localVarQueryParams.Add("approved_by_usernames", parameterToString(localVarOptionals.ApprovedByUsernames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequestBasic
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService List project merge requests
Get all merge requests for this project.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project.
 * @param optional nil or *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsOpts - Optional Parameters:
     * @param "AuthorId" (optional.Int32) -  Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "AuthorUsername" (optional.String) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "AssigneeId" (optional.Int32) -  Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "AssigneeUsername" (optional.Interface of []string) -  Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "ReviewerUsername" (optional.String) -  Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "Labels" (optional.Interface of []string) -  Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "Milestone" (optional.String) -  Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "MyReactionEmoji" (optional.String) -  Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "ReviewerId" (optional.Int32) -  Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "State" (optional.String) -  Returns &#x60;all&#x60; merge requests or just those that are &#x60;opened&#x60;, &#x60;closed&#x60;, &#x60;locked&#x60;, or &#x60;merged&#x60;.
     * @param "OrderBy" (optional.String) -  Returns merge requests ordered by &#x60;created_at&#x60;, &#x60;label_priority&#x60;, &#x60;milestone_due&#x60;, &#x60;popularity&#x60;, &#x60;priority&#x60;, &#x60;title&#x60; or &#x60;updated_at&#x60; fields. Introduced in GitLab 14.8.
     * @param "Sort" (optional.String) -  Returns merge requests sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order.
     * @param "WithLabelsDetails" (optional.Bool) -  If &#x60;true&#x60;, response returns more details for each label in labels field: &#x60;:name&#x60;,&#x60;:color&#x60;, &#x60;:description&#x60;, &#x60;:description_html&#x60;, &#x60;:text_color&#x60;
     * @param "WithMergeStatusRecheck" (optional.Bool) -  If &#x60;true&#x60;, this projection requests (but does not guarantee) that the &#x60;merge_status&#x60; field be recalculated asynchronously. Introduced in GitLab 13.0.
     * @param "CreatedAfter" (optional.Time) -  Returns merge requests created on or after the given time. Expected in ISO 8601 format.
     * @param "CreatedBefore" (optional.Time) -  Returns merge requests created on or before the given time. Expected in ISO 8601 format.
     * @param "UpdatedAfter" (optional.Time) -  Returns merge requests updated on or after the given time. Expected in ISO 8601 format.
     * @param "UpdatedBefore" (optional.Time) -  Returns merge requests updated on or before the given time. Expected in ISO 8601 format.
     * @param "View" (optional.String) -  If simple, returns the &#x60;iid&#x60;, URL, title, description, and basic state of merge request
     * @param "Scope" (optional.String) -  Returns merge requests for the given scope: &#x60;created_by_me&#x60;, &#x60;assigned_to_me&#x60; or &#x60;all&#x60;
     * @param "SourceBranch" (optional.String) -  Returns merge requests with the given source branch
     * @param "SourceProjectId" (optional.Int32) -  Returns merge requests with the given source project id
     * @param "TargetBranch" (optional.String) -  Returns merge requests with the given target branch
     * @param "Search" (optional.String) -  Search merge requests against their &#x60;title&#x60; and &#x60;description&#x60;.
     * @param "In" (optional.String) -  Modify the scope of the search attribute. &#x60;title&#x60;, &#x60;description&#x60;, or a string joining them with comma.
     * @param "Wip" (optional.String) -  Filter merge requests against their &#x60;wip&#x60; status. &#x60;yes&#x60; to return only draft merge requests, &#x60;no&#x60; to return non-draft merge requests.
     * @param "NotAuthorId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given user &#x60;id&#x60;. Mutually exclusive with &#x60;author_username&#x60;. Combine with &#x60;scope&#x3D;all&#x60; or &#x60;scope&#x3D;assigned_to_me&#x60;.
     * @param "NotAuthorUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotAssigneeId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests assigned to the given user &#x60;id&#x60;. &#x60;None&#x60; returns unassigned merge requests. &#x60;Any&#x60; returns merge requests with an assignee.
     * @param "NotAssigneeUsername" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests created by the given &#x60;username&#x60;. Mutually exclusive with &#x60;author_id&#x60;.
     * @param "NotReviewerUsername" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given &#x60;username&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_id&#x60;. Introduced in GitLab 13.8.
     * @param "NotLabels" (optional.Interface of []string) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests matching a comma-separated list of labels. &#x60;None&#x60; lists all merge requests with no labels. &#x60;Any&#x60; lists all merge requests with at least one label. Predefined names are case-insensitive.
     * @param "NotMilestone" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests for a specific milestone. &#x60;None&#x60; returns merge requests with no milestone. &#x60;Any&#x60; returns merge requests that have an assigned milestone.
     * @param "NotMyReactionEmoji" (optional.String) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests reacted by the authenticated user by the given &#x60;emoji&#x60;. &#x60;None&#x60; returns issues not given a reaction. &#x60;Any&#x60; returns issues given at least one reaction.
     * @param "NotReviewerId" (optional.Int32) -  &#x60;&lt;Negated&gt;&#x60; Returns merge requests which have the user as a reviewer with the given user &#x60;id&#x60;. &#x60;None&#x60; returns merge requests with no reviewers. &#x60;Any&#x60; returns merge requests with any reviewer. Mutually exclusive with &#x60;reviewer_username&#x60;.
     * @param "DeployedBefore" (optional.String) -  Returns merge requests deployed before the given date/time. Expected in ISO 8601 format.
     * @param "DeployedAfter" (optional.String) -  Returns merge requests deployed after the given date/time. Expected in ISO 8601 format
     * @param "Environment" (optional.String) -  Returns merge requests deployed to the given environment
     * @param "Approved" (optional.String) -  Filters merge requests by their &#x60;approved&#x60; status. &#x60;yes&#x60; returns only approved merge requests. &#x60;no&#x60; returns only non-approved merge requests.
     * @param "MergeUserId" (optional.Int32) -  Returns merge requests which have been merged by the user with the given user &#x60;id&#x60;. Mutually exclusive with &#x60;merge_user_username&#x60;.
     * @param "MergeUserUsername" (optional.String) -  Returns merge requests which have been merged by the user with the given &#x60;username&#x60;. Mutually exclusive with &#x60;merge_user_id&#x60;.
     * @param "ApproverIds" (optional.String) -  Return merge requests which have specified the users with the given IDs as an individual approver
     * @param "ApprovedByIds" (optional.String) -  Return merge requests which have been approved by the specified users with the given IDs
     * @param "ApprovedByUsernames" (optional.String) -  Return merge requests which have been approved by the specified users with the given             usernames
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page
     * @param "Iids" (optional.Interface of []int32) -  Returns the request having the given &#x60;iid&#x60;.

@return ApiEntitiesMergeRequestBasic
*/

type MergeRequestsApiGetApiV4ProjectsIdMergeRequestsOpts struct {
	AuthorId               optional.Int32
	AuthorUsername         optional.String
	AssigneeId             optional.Int32
	AssigneeUsername       optional.Interface
	ReviewerUsername       optional.String
	Labels                 optional.Interface
	Milestone              optional.String
	MyReactionEmoji        optional.String
	ReviewerId             optional.Int32
	State                  optional.String
	OrderBy                optional.String
	Sort                   optional.String
	WithLabelsDetails      optional.Bool
	WithMergeStatusRecheck optional.Bool
	CreatedAfter           optional.Time
	CreatedBefore          optional.Time
	UpdatedAfter           optional.Time
	UpdatedBefore          optional.Time
	View                   optional.String
	Scope                  optional.String
	SourceBranch           optional.String
	SourceProjectId        optional.Int32
	TargetBranch           optional.String
	Search                 optional.String
	In                     optional.String
	Wip                    optional.String
	NotAuthorId            optional.Int32
	NotAuthorUsername      optional.String
	NotAssigneeId          optional.Int32
	NotAssigneeUsername    optional.Interface
	NotReviewerUsername    optional.String
	NotLabels              optional.Interface
	NotMilestone           optional.String
	NotMyReactionEmoji     optional.String
	NotReviewerId          optional.Int32
	DeployedBefore         optional.String
	DeployedAfter          optional.String
	Environment            optional.String
	Approved               optional.String
	MergeUserId            optional.Int32
	MergeUserUsername      optional.String
	ApproverIds            optional.String
	ApprovedByIds          optional.String
	ApprovedByUsernames    optional.String
	Page                   optional.Int32
	PerPage                optional.Int32
	Iids                   optional.Interface
}

func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequests(ctx context.Context, id string, localVarOptionals *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsOpts) (ApiEntitiesMergeRequestBasic, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequestBasic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AuthorId.IsSet() {
		localVarQueryParams.Add("author_id", parameterToString(localVarOptionals.AuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthorUsername.IsSet() {
		localVarQueryParams.Add("author_username", parameterToString(localVarOptionals.AuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeId.IsSet() {
		localVarQueryParams.Add("assignee_id", parameterToString(localVarOptionals.AssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeUsername.IsSet() {
		localVarQueryParams.Add("assignee_username", parameterToString(localVarOptionals.AssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerUsername.IsSet() {
		localVarQueryParams.Add("reviewer_username", parameterToString(localVarOptionals.ReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Labels.IsSet() {
		localVarQueryParams.Add("labels", parameterToString(localVarOptionals.Labels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Milestone.IsSet() {
		localVarQueryParams.Add("milestone", parameterToString(localVarOptionals.Milestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MyReactionEmoji.IsSet() {
		localVarQueryParams.Add("my_reaction_emoji", parameterToString(localVarOptionals.MyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReviewerId.IsSet() {
		localVarQueryParams.Add("reviewer_id", parameterToString(localVarOptionals.ReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithLabelsDetails.IsSet() {
		localVarQueryParams.Add("with_labels_details", parameterToString(localVarOptionals.WithLabelsDetails.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithMergeStatusRecheck.IsSet() {
		localVarQueryParams.Add("with_merge_status_recheck", parameterToString(localVarOptionals.WithMergeStatusRecheck.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedAfter.IsSet() {
		localVarQueryParams.Add("created_after", parameterToString(localVarOptionals.CreatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedBefore.IsSet() {
		localVarQueryParams.Add("created_before", parameterToString(localVarOptionals.CreatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedAfter.IsSet() {
		localVarQueryParams.Add("updated_after", parameterToString(localVarOptionals.UpdatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedBefore.IsSet() {
		localVarQueryParams.Add("updated_before", parameterToString(localVarOptionals.UpdatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceBranch.IsSet() {
		localVarQueryParams.Add("source_branch", parameterToString(localVarOptionals.SourceBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceProjectId.IsSet() {
		localVarQueryParams.Add("source_project_id", parameterToString(localVarOptionals.SourceProjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetBranch.IsSet() {
		localVarQueryParams.Add("target_branch", parameterToString(localVarOptionals.TargetBranch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.In.IsSet() {
		localVarQueryParams.Add("in", parameterToString(localVarOptionals.In.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wip.IsSet() {
		localVarQueryParams.Add("wip", parameterToString(localVarOptionals.Wip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorId.IsSet() {
		localVarQueryParams.Add("not[author_id]", parameterToString(localVarOptionals.NotAuthorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAuthorUsername.IsSet() {
		localVarQueryParams.Add("not[author_username]", parameterToString(localVarOptionals.NotAuthorUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeId.IsSet() {
		localVarQueryParams.Add("not[assignee_id]", parameterToString(localVarOptionals.NotAssigneeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotAssigneeUsername.IsSet() {
		localVarQueryParams.Add("not[assignee_username]", parameterToString(localVarOptionals.NotAssigneeUsername.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerUsername.IsSet() {
		localVarQueryParams.Add("not[reviewer_username]", parameterToString(localVarOptionals.NotReviewerUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotLabels.IsSet() {
		localVarQueryParams.Add("not[labels]", parameterToString(localVarOptionals.NotLabels.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NotMilestone.IsSet() {
		localVarQueryParams.Add("not[milestone]", parameterToString(localVarOptionals.NotMilestone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotMyReactionEmoji.IsSet() {
		localVarQueryParams.Add("not[my_reaction_emoji]", parameterToString(localVarOptionals.NotMyReactionEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotReviewerId.IsSet() {
		localVarQueryParams.Add("not[reviewer_id]", parameterToString(localVarOptionals.NotReviewerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedBefore.IsSet() {
		localVarQueryParams.Add("deployed_before", parameterToString(localVarOptionals.DeployedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeployedAfter.IsSet() {
		localVarQueryParams.Add("deployed_after", parameterToString(localVarOptionals.DeployedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Environment.IsSet() {
		localVarQueryParams.Add("environment", parameterToString(localVarOptionals.Environment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Approved.IsSet() {
		localVarQueryParams.Add("approved", parameterToString(localVarOptionals.Approved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserId.IsSet() {
		localVarQueryParams.Add("merge_user_id", parameterToString(localVarOptionals.MergeUserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MergeUserUsername.IsSet() {
		localVarQueryParams.Add("merge_user_username", parameterToString(localVarOptionals.MergeUserUsername.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApproverIds.IsSet() {
		localVarQueryParams.Add("approver_ids", parameterToString(localVarOptionals.ApproverIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApprovedByIds.IsSet() {
		localVarQueryParams.Add("approved_by_ids", parameterToString(localVarOptionals.ApprovedByIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApprovedByUsernames.IsSet() {
		localVarQueryParams.Add("approved_by_usernames", parameterToString(localVarOptionals.ApprovedByUsernames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Iids.IsSet() {
		localVarQueryParams.Add("iids", parameterToString(localVarOptionals.Iids.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequestBasic
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get single merge request
Shows information about a single merge request. Note: the &#x60;changes_count&#x60; value in the response is a string, not an integer. This is because when an merge request has too many changes to display and store, it is capped at 1,000. In that case, the API returns the string &#x60;\&quot;1000+\&quot;&#x60; for the changes count.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project.
 * @param mergeRequestIid The internal ID of the merge request.
 * @param optional nil or *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidOpts - Optional Parameters:
     * @param "RenderHtml" (optional.Bool) -  If &#x60;true&#x60;, response includes rendered HTML for title and description.
     * @param "IncludeDivergedCommitsCount" (optional.Bool) -  If &#x60;true&#x60;, response includes the commits behind the target branch.
     * @param "IncludeRebaseInProgress" (optional.Bool) -  If &#x60;true&#x60;, response includes whether a rebase operation is in progress.

@return ApiEntitiesMergeRequest
*/

type MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidOpts struct {
	RenderHtml                  optional.Bool
	IncludeDivergedCommitsCount optional.Bool
	IncludeRebaseInProgress     optional.Bool
}

func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIid(ctx context.Context, id string, mergeRequestIid int32, localVarOptionals *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidOpts) (ApiEntitiesMergeRequest, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequest
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.RenderHtml.IsSet() {
		localVarQueryParams.Add("render_html", parameterToString(localVarOptionals.RenderHtml.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeDivergedCommitsCount.IsSet() {
		localVarQueryParams.Add("include_diverged_commits_count", parameterToString(localVarOptionals.IncludeDivergedCommitsCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeRebaseInProgress.IsSet() {
		localVarQueryParams.Add("include_rebase_in_progress", parameterToString(localVarOptionals.IncludeRebaseInProgress.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequest
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get single merge request changes
Shows information about the merge request including its files and changes.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project.
 * @param mergeRequestIid
 * @param optional nil or *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidChangesOpts - Optional Parameters:
     * @param "Unidiff" (optional.Bool) -  A diff in a Unified diff format

@return ApiEntitiesMergeRequestChanges
*/

type MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidChangesOpts struct {
	Unidiff optional.Bool
}

func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidChanges(ctx context.Context, id string, mergeRequestIid int32, localVarOptionals *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidChangesOpts) (ApiEntitiesMergeRequestChanges, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequestChanges
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Unidiff.IsSet() {
		localVarQueryParams.Add("unidiff", parameterToString(localVarOptionals.Unidiff.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequestChanges
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService List issues that close on merge
Get all the issues that would be closed by merging the provided merge request.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project.
 * @param mergeRequestIid
 * @param optional nil or *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidClosesIssuesOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page

@return ApiEntitiesMrNote
*/

type MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidClosesIssuesOpts struct {
	Page    optional.Int32
	PerPage optional.Int32
}

func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidClosesIssues(ctx context.Context, id string, mergeRequestIid int32, localVarOptionals *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidClosesIssuesOpts) (ApiEntitiesMrNote, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMrNote
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/closes_issues"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMrNote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get single merge request commits
Get a list of merge request commits.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid

@return ApiEntitiesCommit
*/
func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidCommits(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesCommit, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesCommit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/commits"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesCommit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService List merge request context commits
Get a list of merge request context commits.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid

@return ApiEntitiesCommit
*/
func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidContextCommits(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesCommit, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesCommit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/context_commits"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesCommit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get the merge request diffs
Get a list of merge request diffs.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project.
 * @param mergeRequestIid
 * @param optional nil or *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidDiffsOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page
     * @param "Unidiff" (optional.Bool) -  A diff in a Unified diff format

@return ApiEntitiesDiff
*/

type MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidDiffsOpts struct {
	Page    optional.Int32
	PerPage optional.Int32
	Unidiff optional.Bool
}

func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidDiffs(ctx context.Context, id string, mergeRequestIid int32, localVarOptionals *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidDiffsOpts) (ApiEntitiesDiff, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesDiff
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/diffs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unidiff.IsSet() {
		localVarQueryParams.Add("unidiff", parameterToString(localVarOptionals.Unidiff.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesDiff
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Returns the up to date merge-ref HEAD commit
Returns the up to date merge-ref HEAD commit
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid
*/
func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidMergeRef(ctx context.Context, id string, mergeRequestIid int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/merge_ref"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get single merge request participants
Get a list of merge request participants.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid

@return ApiEntitiesUserBasic
*/
func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidParticipants(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesUserBasic, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesUserBasic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/participants"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesUserBasic
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get single merge request pipelines
Get a list of merge request pipelines.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid

@return ApiEntitiesCiPipelineBasic
*/
func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidPipelines(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesCiPipelineBasic, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesCiPipelineBasic
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/pipelines"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesCiPipelineBasic
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get single merge request reviewers
Get a list of merge request reviewers.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid

@return ApiEntitiesMergeRequestReviewer
*/
func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidReviewers(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesMergeRequestReviewer, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequestReviewer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/reviewers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequestReviewer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get time tracking stats
Get time tracking stats
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid The internal ID of the merge_request

@return ApiEntitiesIssuableTimeStats
*/
func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidTimeStats(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesIssuableTimeStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesIssuableTimeStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/time_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesIssuableTimeStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get a list of merge request diff versions
This feature was introduced in GitLab 8.12.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project
 * @param mergeRequestIid The internal ID of the merge request
 * @param optional nil or *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidVersionsOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Current page number
     * @param "PerPage" (optional.Int32) -  Number of items per page

@return []ApiEntitiesMergeRequestDiff
*/

type MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidVersionsOpts struct {
	Page    optional.Int32
	PerPage optional.Int32
}

func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidVersions(ctx context.Context, id string, mergeRequestIid int32, localVarOptionals *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidVersionsOpts) ([]ApiEntitiesMergeRequestDiff, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []ApiEntitiesMergeRequestDiff
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []ApiEntitiesMergeRequestDiff
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Get a single merge request diff version
This feature was introduced in GitLab 8.12.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID or URL-encoded path of the project
 * @param mergeRequestIid The internal ID of the merge request
 * @param versionId The ID of the merge request diff version
 * @param optional nil or *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidVersionsVersionIdOpts - Optional Parameters:
     * @param "Unidiff" (optional.Bool) -  A diff in a Unified diff format

@return ApiEntitiesMergeRequestDiffFull
*/

type MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidVersionsVersionIdOpts struct {
	Unidiff optional.Bool
}

func (a *MergeRequestsApiService) GetApiV4ProjectsIdMergeRequestsMergeRequestIidVersionsVersionId(ctx context.Context, id string, mergeRequestIid int32, versionId int32, localVarOptionals *MergeRequestsApiGetApiV4ProjectsIdMergeRequestsMergeRequestIidVersionsVersionIdOpts) (ApiEntitiesMergeRequestDiffFull, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequestDiffFull
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/versions/{version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version_id"+"}", fmt.Sprintf("%v", versionId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Unidiff.IsSet() {
		localVarQueryParams.Add("unidiff", parameterToString(localVarOptionals.Unidiff.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequestDiffFull
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Create merge request
Create a new merge request.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param postApiV4ProjectsIdMergeRequests

@return ApiEntitiesMergeRequest
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequests(ctx context.Context, id string, postApiV4ProjectsIdMergeRequests PostApiV4ProjectsIdMergeRequests) (ApiEntitiesMergeRequest, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequest
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &postApiV4ProjectsIdMergeRequests
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesMergeRequest
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Add spent time for a merge_request
Adds spent time for this merge_request.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid The internal ID of the merge_request.
  - @param postApiV4ProjectsIdMergeRequestsMergeRequestIidAddSpentTime

@return ApiEntitiesIssuableTimeStats
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequestsMergeRequestIidAddSpentTime(ctx context.Context, id string, mergeRequestIid int32, postApiV4ProjectsIdMergeRequestsMergeRequestIidAddSpentTime PostApiV4ProjectsIdMergeRequestsMergeRequestIidAddSpentTime) (ApiEntitiesIssuableTimeStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesIssuableTimeStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/add_spent_time"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &postApiV4ProjectsIdMergeRequestsMergeRequestIidAddSpentTime
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesIssuableTimeStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Cancel Merge When Pipeline Succeeds
Cancel merge if \&quot;Merge When Pipeline Succeeds\&quot; is enabled
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid

@return ApiEntitiesMergeRequest
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequestsMergeRequestIidCancelMergeWhenPipelineSucceeds(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesMergeRequest, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequest
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/cancel_merge_when_pipeline_succeeds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesMergeRequest
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Create merge request context commits
Create a list of merge request context commits.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid
  - @param postApiV4ProjectsIdMergeRequestsMergeRequestIidContextCommits

@return ApiEntitiesCommit
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequestsMergeRequestIidContextCommits(ctx context.Context, id string, mergeRequestIid int32, postApiV4ProjectsIdMergeRequestsMergeRequestIidContextCommits PostApiV4ProjectsIdMergeRequestsMergeRequestIidContextCommits) (ApiEntitiesCommit, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesCommit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/context_commits"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &postApiV4ProjectsIdMergeRequestsMergeRequestIidContextCommits
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesCommit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Create merge request pipeline
Create a new pipeline for a merge request. A pipeline created via this endpoint doesnâ€™t run a regular branch/tag pipeline. It requires &#x60;.gitlab-ci.yml&#x60; to be configured with &#x60;only: [merge_requests]&#x60; to create jobs.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid

@return ApiEntitiesCiPipeline
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequestsMergeRequestIidPipelines(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesCiPipeline, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesCiPipeline
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/pipelines"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesCiPipeline
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Reset spent time for a merge_request
Resets the total spent time for this merge_request to 0 seconds.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid The internal ID of the merge_request

@return ApiEntitiesIssuableTimeStats
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequestsMergeRequestIidResetSpentTime(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesIssuableTimeStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesIssuableTimeStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/reset_spent_time"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesIssuableTimeStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Reset the time estimate for a project merge_request
Resets the estimated time for this merge_request to 0 seconds.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid The internal ID of the merge_request.

@return ApiEntitiesIssuableTimeStats
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequestsMergeRequestIidResetTimeEstimate(ctx context.Context, id string, mergeRequestIid int32) (ApiEntitiesIssuableTimeStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesIssuableTimeStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/reset_time_estimate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesIssuableTimeStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Set a time estimate for a merge_request
Sets an estimated time of work for this merge_request.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid The internal ID of the merge_request.
  - @param postApiV4ProjectsIdMergeRequestsMergeRequestIidTimeEstimate

@return ApiEntitiesIssuableTimeStats
*/
func (a *MergeRequestsApiService) PostApiV4ProjectsIdMergeRequestsMergeRequestIidTimeEstimate(ctx context.Context, id string, mergeRequestIid int32, postApiV4ProjectsIdMergeRequestsMergeRequestIidTimeEstimate PostApiV4ProjectsIdMergeRequestsMergeRequestIidTimeEstimate) (ApiEntitiesIssuableTimeStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesIssuableTimeStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/time_estimate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &postApiV4ProjectsIdMergeRequestsMergeRequestIidTimeEstimate
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApiEntitiesIssuableTimeStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Update merge request
Updates an existing merge request. You can change the target branch, title, or even close the merge request.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid
  - @param putApiV4ProjectsIdMergeRequestsMergeRequestIid

@return ApiEntitiesMergeRequest
*/
func (a *MergeRequestsApiService) PutApiV4ProjectsIdMergeRequestsMergeRequestIid(ctx context.Context, id string, mergeRequestIid int32, putApiV4ProjectsIdMergeRequestsMergeRequestIid PutApiV4ProjectsIdMergeRequestsMergeRequestIid) (ApiEntitiesMergeRequest, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequest
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &putApiV4ProjectsIdMergeRequestsMergeRequestIid
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequest
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Merge a merge request
Accept and merge changes submitted with the merge request using this API.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid
  - @param putApiV4ProjectsIdMergeRequestsMergeRequestIidMerge

@return ApiEntitiesMergeRequest
*/
func (a *MergeRequestsApiService) PutApiV4ProjectsIdMergeRequestsMergeRequestIidMerge(ctx context.Context, id string, mergeRequestIid int32, putApiV4ProjectsIdMergeRequestsMergeRequestIidMerge PutApiV4ProjectsIdMergeRequestsMergeRequestIidMerge) (ApiEntitiesMergeRequest, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesMergeRequest
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &putApiV4ProjectsIdMergeRequestsMergeRequestIidMerge
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesMergeRequest
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MergeRequestsApiService Rebase a merge request
Automatically rebase the &#x60;source_branch&#x60; of the merge request against its &#x60;target_branch&#x60;. This feature was added in GitLab 11.6
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id The ID or URL-encoded path of the project.
  - @param mergeRequestIid
  - @param putApiV4ProjectsIdMergeRequestsMergeRequestIidRebase
*/
func (a *MergeRequestsApiService) PutApiV4ProjectsIdMergeRequestsMergeRequestIidRebase(ctx context.Context, id string, mergeRequestIid int32, putApiV4ProjectsIdMergeRequestsMergeRequestIidRebase PutApiV4ProjectsIdMergeRequestsMergeRequestIidRebase) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/rebase"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &putApiV4ProjectsIdMergeRequestsMergeRequestIidRebase
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
MergeRequestsApiService Remove all merge request approvals
Clear all approvals of merge request. This feature was added in GitLab 15.4
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id
  - @param mergeRequestIid
*/
func (a *MergeRequestsApiService) PutApiV4ProjectsIdMergeRequestsMergeRequestIidResetApprovals(ctx context.Context, id int32, mergeRequestIid int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/projects/{id}/merge_requests/{merge_request_iid}/reset_approvals"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_request_iid"+"}", fmt.Sprintf("%v", mergeRequestIid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
