/*
 * GitLab API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: v4
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ApplicationApiService service

/*
ApplicationApiService
Get the current appearance
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ApiEntitiesAppearance
*/
func (a *ApplicationApiService) GetApiV4ApplicationAppearance(ctx context.Context) (ApiEntitiesAppearance, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesAppearance
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/application/appearance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesAppearance
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationApiService
Get the current application statistics
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ApiEntitiesApplicationStatistics
*/
func (a *ApplicationApiService) GetApiV4ApplicationStatistics(ctx context.Context) (ApiEntitiesApplicationStatistics, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesApplicationStatistics
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/application/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesApplicationStatistics
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationApiService
Modify appearance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ApplicationApiPutApiV4ApplicationAppearanceOpts - Optional Parameters:
     * @param "Title" (optional.String) -  Instance title on the sign in / sign up page
     * @param "Description" (optional.String) -  Markdown text shown on the sign in / sign up page
     * @param "PwaName" (optional.String) -  Name of the Progressive Web App
     * @param "PwaShortName" (optional.String) -  Optional, short name for Progressive Web App
     * @param "PwaDescription" (optional.String) -  An explanation of what the Progressive Web App does
     * @param "Logo" (optional.Interface of *os.File) -  Instance image used on the sign in / sign up page
     * @param "PwaIcon" (optional.Interface of *os.File) -  Icon used for Progressive Web App
     * @param "HeaderLogo" (optional.Interface of *os.File) -  Instance image used for the main navigation bar
     * @param "Favicon" (optional.Interface of *os.File) -  Instance favicon in .ico/.png format
     * @param "MemberGuidelines" (optional.String) -  Markdown text shown on the members page of a group or project
     * @param "NewProjectGuidelines" (optional.String) -  Markdown text shown on the new project page
     * @param "ProfileImageGuidelines" (optional.String) -  Markdown text shown on the profile page below Public Avatar
     * @param "HeaderMessage" (optional.String) -  Message within the system header bar
     * @param "FooterMessage" (optional.String) -  Message within the system footer bar
     * @param "MessageBackgroundColor" (optional.String) -  Background color for the system header / footer bar
     * @param "MessageFontColor" (optional.String) -  Font color for the system header / footer bar
     * @param "EmailHeaderAndFooterEnabled" (optional.Bool) -  Add header and footer to all outgoing emails if enabled

@return ApiEntitiesAppearance
*/

type ApplicationApiPutApiV4ApplicationAppearanceOpts struct {
	Title                       optional.String
	Description                 optional.String
	PwaName                     optional.String
	PwaShortName                optional.String
	PwaDescription              optional.String
	Logo                        optional.Interface
	PwaIcon                     optional.Interface
	HeaderLogo                  optional.Interface
	Favicon                     optional.Interface
	MemberGuidelines            optional.String
	NewProjectGuidelines        optional.String
	ProfileImageGuidelines      optional.String
	HeaderMessage               optional.String
	FooterMessage               optional.String
	MessageBackgroundColor      optional.String
	MessageFontColor            optional.String
	EmailHeaderAndFooterEnabled optional.Bool
}

func (a *ApplicationApiService) PutApiV4ApplicationAppearance(ctx context.Context, localVarOptionals *ApplicationApiPutApiV4ApplicationAppearanceOpts) (ApiEntitiesAppearance, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApiEntitiesAppearance
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v4/application/appearance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Title.IsSet() {
		localVarFormParams.Add("title", parameterToString(localVarOptionals.Title.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PwaName.IsSet() {
		localVarFormParams.Add("pwa_name", parameterToString(localVarOptionals.PwaName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PwaShortName.IsSet() {
		localVarFormParams.Add("pwa_short_name", parameterToString(localVarOptionals.PwaShortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PwaDescription.IsSet() {
		localVarFormParams.Add("pwa_description", parameterToString(localVarOptionals.PwaDescription.Value(), ""))
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.Logo.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.Logo.Value().(*os.File)
		if !localVarFileOk {
			return localVarReturnValue, nil, reportError("logo should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := io.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.PwaIcon.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.PwaIcon.Value().(*os.File)
		if !localVarFileOk {
			return localVarReturnValue, nil, reportError("pwaIcon should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := io.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.HeaderLogo.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.HeaderLogo.Value().(*os.File)
		if !localVarFileOk {
			return localVarReturnValue, nil, reportError("headerLogo should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := io.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.Favicon.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.Favicon.Value().(*os.File)
		if !localVarFileOk {
			return localVarReturnValue, nil, reportError("favicon should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := io.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.MemberGuidelines.IsSet() {
		localVarFormParams.Add("member_guidelines", parameterToString(localVarOptionals.MemberGuidelines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewProjectGuidelines.IsSet() {
		localVarFormParams.Add("new_project_guidelines", parameterToString(localVarOptionals.NewProjectGuidelines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProfileImageGuidelines.IsSet() {
		localVarFormParams.Add("profile_image_guidelines", parameterToString(localVarOptionals.ProfileImageGuidelines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeaderMessage.IsSet() {
		localVarFormParams.Add("header_message", parameterToString(localVarOptionals.HeaderMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FooterMessage.IsSet() {
		localVarFormParams.Add("footer_message", parameterToString(localVarOptionals.FooterMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MessageBackgroundColor.IsSet() {
		localVarFormParams.Add("message_background_color", parameterToString(localVarOptionals.MessageBackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MessageFontColor.IsSet() {
		localVarFormParams.Add("message_font_color", parameterToString(localVarOptionals.MessageFontColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EmailHeaderAndFooterEnabled.IsSet() {
		localVarFormParams.Add("email_header_and_footer_enabled", parameterToString(localVarOptionals.EmailHeaderAndFooterEnabled.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApiEntitiesAppearance
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
